## A* (A-Star) Algorithm 介紹與原理

### 1. 介紹
A* 演算法（A-Star Algorithm）是一種基於啟發式搜索的路徑尋找算法，常用於圖形或網格中尋找從起點到終點的最短路徑。A* 演算法融合了**Dijkstra 算法**的最短路徑搜索能力和**最佳優先搜索**的啟發式搜索能力，使得它在搜尋過程中能夠更加高效地找到最短路徑。

### 2. 原理
A* 演算法利用了三個主要參數來評估每個節點的優先級：

- **g(n)**：從起點到當前節點 n 的實際成本（即從起點出發，經過若干節點，到達節點 n 的總距離）。
- **h(n)**：從當前節點 n 到目標節點的預估成本，這個成本是根據啟發式函數來估計的。通常使用曼哈頓距離或歐氏距離作為啟發式函數。
- **f(n)**：節點 n 的總評分值，定義為：
  \[
  f(n) = g(n) + h(n)
  \]
  其中：
  - **g(n)** 是從起點到 n 的實際成本
  - **h(n)** 是從 n 到終點的預估成本

A* 演算法的基本步驟如下：

1. **初始化**：將起點添加到開放列表（Open List）中，開放列表用來記錄需要探索的節點。
2. **選擇當前節點**：從開放列表中選擇 **f(n)** 值最小的節點作為當前節點。
3. **生成鄰居節點**：對當前節點的所有鄰居進行探索，並根據 **g(n)** 和 **h(n)** 更新它們的 **f(n)** 值。
4. **檢查目標節點**：如果當前節點是目標節點，則可以終止算法並返回路徑。
5. **更新列表**：將當前節點移至閉合列表（Closed List），並將所有鄰居節點添加到開放列表中（若尚未探索過）。
6. **重複步驟 2 至步驟 5**：直到找到目標節點或開放列表為空。

### 3. 優點
- **最優性**：如果啟發式函數是可接受的（即它不會高估到達目標的成本），A* 算法保證能找到最短路徑。
- **效率**：相較於 Dijkstra 算法，A* 通常能夠更高效地找到最短路徑，因為它根據啟發式估計引導搜索方向。

### 4. 缺點
- **計算需求高**：在某些情況下，A* 演算法可能需要大量的內存和計算，尤其是在大規模地圖上。
- **依賴於啟發式函數**：選擇適當的啟發式函數對 A* 的性能有很大影響，不恰當的啟發式函數可能會降低其效率。

---

## D* (D-Star) Algorithm 介紹與原理

### 1. 介紹
D* 演算法是一種增量式的啟發式搜索算法，專門用於處理動態環境中的路徑規劃問題。與 A* 演算法不同，D* 演算法能夠動態更新路徑，當環境發生變化（例如障礙物位置變動）時，能夠重新計算並調整路徑。

D* 演算法最早由 **Anthony Stentz** 提出，主要用於機器人導航和自動駕駛等領域。

### 2. 原理
D* 演算法的核心思想是通過反向搜索的方式（從目標節點開始向起點進行搜索），並根據環境變化逐步更新路徑。D* 的運行過程與 A* 類似，但它有一些重要的特點和改進：

1. **增量更新**：當環境中的障礙物發生變化時，D* 演算法可以只更新受影響的部分，而不需要重新計算整個路徑。這使得 D* 在動態環境中具有優勢。
2. **反向搜索**：D* 演算法首先從目標節點開始進行反向搜索，通過估算未來可能的路徑來確定最佳路徑。
3. **優先級隊列**：D* 使用優先級隊列來處理節點，並依據路徑的成本進行排序。當有障礙物變動時，D* 會優先處理受影響的區域。

### 3. 操作步驟
1. **初始化**：與 A* 類似，D* 也需要初始化起點和目標點，並且計算各個節點的成本。不同的是，D* 開始是反向計算的。
2. **搜索**：在進行搜索時，D* 基於當前環境的信息進行路徑搜尋，並隨著新信息的加入（如障礙物位置的變化）進行增量更新。
3. **動態更新**：當障礙物位置或環境變化時，D* 不需要重新從頭開始計算，而是根據局部變動更新受影響的路徑。

### 4. 優點
- **動態適應**：D* 的最大優勢在於它能夠應對動態環境，即在路徑規劃過程中隨時更新環境變化，並調整最短路徑。
- **效率**：相比於重新運行 A*，D* 只需要更新受影響的區域，這樣可以節省計算資源和時間。

### 5. 缺點
- **實現複雜度高**：D* 的實現較為複雜，需要高效的數據結構來管理優先級隊列和增量更新。
- **性能問題**：在某些情況下，D* 的運算和內存需求可能會隨著環境的動態變化而增大。

---

## 小結
- **A*** 演算法適用於靜態環境，它能夠快速找到最短路徑，並且在啟發式函數的選擇上具有很大的靈活性。
- **D*** 演算法則更適合動態環境，它能夠根據環境變化進行增量更新，從而避免了每次都重新計算整個路徑的需要。
